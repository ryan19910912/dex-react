import {
  require_src,
  require_src2,
  require_src3
} from "./chunk-B6ND6HPX.js";
import {
  _classPrivateMethodGet,
  _classPrivateMethodInitSpec
} from "./chunk-4MZS4CQC.js";
import {
  WagmiAdapter
} from "./chunk-DCR354S2.js";
import {
  assertWindowEthereum
} from "./chunk-FETDTUNB.js";
import {
  _classPrivateFieldGet,
  _classPrivateFieldInitSpec,
  _classPrivateFieldSet
} from "./chunk-GI3CIENS.js";
import {
  _defineProperty,
  eventemitter3_default
} from "./chunk-44DZRTPR.js";
import {
  Contract,
  Wallet,
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-W2YF4XCL.js";
import {
  lib_exports19 as lib_exports
} from "./chunk-AVG4MCCG.js";
import {
  Ethereum,
  defaultChains
} from "./chunk-Z75DXWY4.js";
import {
  init_shim,
  require_buffer
} from "./chunk-ZGMFR26H.js";
import {
  __toESM
} from "./chunk-IKJM6GHQ.js";

// node_modules/@thirdweb-dev/wallets/evm/wallets/paper-wallet/dist/thirdweb-dev-wallets-evm-wallets-paper-wallet.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/wallets/dist/base-901ad5ac.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/wallets/evm/wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js
init_shim();
init_lib();
function chainIdToThirdwebRpc(chainId) {
  return `https://${chainId}.rpc.thirdweb.com`;
}
var EIP1271_ABI = ["function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)"];
var EIP1271_MAGICVALUE = "0x1626ba7e";
async function checkContractWalletSignature(message, signature, address, chainId) {
  const provider = new lib_exports.JsonRpcProvider(chainIdToThirdwebRpc(chainId));
  const walletContract = new Contract(address, EIP1271_ABI, provider);
  const _hashMessage = utils_exports.hashMessage(message);
  try {
    const res = await walletContract.isValidSignature(_hashMessage, signature);
    return res === EIP1271_MAGICVALUE;
  } catch {
    return false;
  }
}
var AbstractWallet = class extends eventemitter3_default {
  constructor() {
    super(...arguments);
    _defineProperty(this, "type", "evm");
    _defineProperty(this, "signerPromise", void 0);
  }
  async getAddress() {
    const signer = await this.getCachedSigner();
    return signer.getAddress();
  }
  async getChainId() {
    const signer = await this.getCachedSigner();
    return signer.getChainId();
  }
  async signMessage(message) {
    const signer = await this.getCachedSigner();
    return await signer.signMessage(message);
  }
  async verifySignature(message, signature, address, chainId) {
    const messageHash = utils_exports.hashMessage(message);
    const messageHashBytes = utils_exports.arrayify(messageHash);
    const recoveredAddress = utils_exports.recoverAddress(messageHashBytes, signature);
    if (recoveredAddress === address) {
      return true;
    }
    if (chainId !== void 0) {
      try {
        const isValid = await checkContractWalletSignature(message, signature, address, chainId || 1);
        return isValid;
      } catch {
      }
    }
    return false;
  }
  async getCachedSigner() {
    if (this.signerPromise) {
      return this.signerPromise;
    }
    this.signerPromise = this.getSigner().catch(() => {
      this.signerPromise = void 0;
      throw new Error("Unable to get a signer!");
    });
    return this.signerPromise;
  }
};

// node_modules/@thirdweb-dev/wallets/dist/base-901ad5ac.browser.esm.js
var PREFIX = "__TW__";
var AsyncLocalStorage = class {
  constructor(name) {
    _defineProperty(this, "name", void 0);
    this.name = name;
  }
  getItem(key) {
    return new Promise((res) => {
      res(localStorage.getItem(`${PREFIX}/${this.name}/${key}`));
    });
  }
  setItem(key, value) {
    return new Promise((res, rej) => {
      try {
        localStorage.setItem(`${PREFIX}/${this.name}/${key}`, value);
        res();
      } catch (e) {
        rej(e);
      }
    });
  }
  removeItem(key) {
    return new Promise((res) => {
      localStorage.removeItem(`${PREFIX}/${this.name}/${key}`);
      res();
    });
  }
};
function createAsyncLocalStorage(name) {
  return new AsyncLocalStorage(name);
}
var DEFAULT_DAPP_META = {
  name: "thirdweb powered dApp",
  url: "https://thirdweb.com",
  description: "thirdweb powered dApp",
  logoUrl: "https://thirdweb.com/favicon.ico",
  isDarkMode: true
};
var _connect = /* @__PURE__ */ new WeakSet();
var _subscribeToEvents = /* @__PURE__ */ new WeakSet();
var AbstractClientWallet = class extends AbstractWallet {
  getMeta() {
    return this.constructor.meta;
  }
  constructor(walletId, options) {
    super();
    _classPrivateMethodInitSpec(this, _subscribeToEvents);
    _classPrivateMethodInitSpec(this, _connect);
    _defineProperty(this, "walletId", void 0);
    _defineProperty(this, "walletStorage", void 0);
    _defineProperty(this, "chains", void 0);
    _defineProperty(this, "dappMetadata", void 0);
    _defineProperty(this, "options", void 0);
    this.walletId = walletId;
    this.options = options;
    this.chains = (options == null ? void 0 : options.chains) || defaultChains;
    this.dappMetadata = (options == null ? void 0 : options.dappMetadata) || DEFAULT_DAPP_META;
    this.walletStorage = (options == null ? void 0 : options.walletStorage) || createAsyncLocalStorage(this.walletId);
  }
  async autoConnect(connectOptions) {
    const options = connectOptions ? {
      ...connectOptions,
      chainId: void 0
    } : void 0;
    return _classPrivateMethodGet(this, _connect, _connect2).call(this, true, options);
  }
  async connect(connectOptions) {
    const address = await _classPrivateMethodGet(this, _connect, _connect2).call(this, false, connectOptions);
    if (!address) {
      throw new Error("Failed to connect to the wallet.");
    }
    return address;
  }
  async getSigner() {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    return await connector.getSigner();
  }
  async disconnect() {
    const connector = await this.getConnector();
    if (connector) {
      await connector.disconnect();
      this.emit("disconnect");
      connector.removeAllListeners();
    }
  }
  async switchChain(chainId) {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    if (!connector.switchChain) {
      throw new Error("Wallet does not support switching chains");
    }
    return await connector.switchChain(chainId);
  }
  async updateChains(chains) {
    this.chains = chains;
    const connector = await this.getConnector();
    connector.updateChains(chains);
  }
};
async function _connect2(isAutoConnect, connectOptions) {
  const connector = await this.getConnector();
  _classPrivateMethodGet(this, _subscribeToEvents, _subscribeToEvents2).call(this, connector);
  const isConnected = await connector.isConnected();
  if (isConnected) {
    const address2 = await connector.getAddress();
    connector.setupListeners();
    if (connectOptions == null ? void 0 : connectOptions.chainId) {
      await connector.switchChain(connectOptions == null ? void 0 : connectOptions.chainId);
    }
    this.emit("connect", {
      address: address2,
      chainId: await this.getChainId()
    });
    return address2;
  }
  if (isAutoConnect) {
    throw new Error("Failed to auto connect to the wallet.");
  }
  const address = await connector.connect(connectOptions);
  return address;
}
async function _subscribeToEvents2(connector) {
  connector.on("connect", (data) => {
    var _a;
    this.emit("connect", {
      address: data.account,
      chainId: (_a = data.chain) == null ? void 0 : _a.id
    });
  });
  connector.on("change", (data) => {
    var _a;
    this.emit("change", {
      address: data.account,
      chainId: (_a = data.chain) == null ? void 0 : _a.id
    });
  });
  connector.on("message", (data) => {
    this.emit("message", data);
  });
  connector.on("disconnect", async () => {
    this.emit("disconnect");
  });
  connector.on("error", (error) => this.emit("error", error));
}
_defineProperty(AbstractClientWallet, "meta", void 0);

// node_modules/@thirdweb-dev/wallets/evm/wallets/paper-wallet/dist/thirdweb-dev-wallets-evm-wallets-paper-wallet.browser.esm.js
init_lib();
var PaperWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Paper Wallet";
  }
  constructor(options) {
    super(PaperWallet.id, {
      ...options
    });
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "clientId", void 0);
    _defineProperty(this, "chain", void 0);
    this.clientId = options.clientId;
    this.chain = options.chain;
    this.chains = options.chains;
  }
  async getConnector() {
    if (!this.connector) {
      const {
        PaperWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-paper.browser.esm-DYZQGWWX.js");
      this.connector = new PaperWalletConnector({
        clientId: this.clientId,
        chain: this.chain,
        chains: this.chains
      });
    }
    return this.connector;
  }
  async updateChains(chains) {
    this.chains = chains;
  }
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
};
_defineProperty(PaperWallet, "id", "PaperWallet");
_defineProperty(PaperWallet, "meta", {
  name: "Paper Wallet",
  iconURL: "ipfs://QmNrLXtPoFrh4yjZbXui39zUMozS1oetpgU8dvZhFAxfRa/paper-logo-icon.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/device-wallet/dist/thirdweb-dev-wallets-evm-wallets-device-wallet.browser.esm.js
init_shim();
init_lib();
var STORAGE_KEY_WALLET_DATA = "deviceWalletData";
var _ethersWallet = /* @__PURE__ */ new WeakMap();
var _storage2 = /* @__PURE__ */ new WeakMap();
var _saveData = /* @__PURE__ */ new WeakSet();
var DeviceWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Device Wallet";
  }
  constructor(options) {
    super(DeviceWallet.id, options);
    _classPrivateMethodInitSpec(this, _saveData);
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "options", void 0);
    _classPrivateFieldInitSpec(this, _ethersWallet, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _storage2, {
      writable: true,
      value: void 0
    });
    this.options = options || {};
    _classPrivateFieldSet(this, _storage2, (options == null ? void 0 : options.storage) || createAsyncLocalStorage("deviceWallet"));
  }
  async getConnector() {
    if (!this.connector) {
      const {
        DeviceWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-device-wallet.browser.esm-C6OMSPJ2.js");
      if (!_classPrivateFieldGet(this, _ethersWallet)) {
        throw new Error("wallet is not initialized");
      }
      this.connector = new DeviceWalletConnector({
        chain: this.options.chain || Ethereum,
        ethersWallet: _classPrivateFieldGet(this, _ethersWallet),
        chains: this.options.chains || defaultChains
      });
    }
    return this.connector;
  }
  async generate() {
    if (_classPrivateFieldGet(this, _ethersWallet)) {
      throw new Error("wallet is already initialized");
    }
    _classPrivateFieldSet(this, _ethersWallet, Wallet.createRandom());
    return _classPrivateFieldGet(this, _ethersWallet).address;
  }
  async import(options) {
    if (_classPrivateFieldGet(this, _ethersWallet)) {
      throw new Error("wallet is already initialized");
    }
    if ("encryptedJson" in options) {
      _classPrivateFieldSet(this, _ethersWallet, await Wallet.fromEncryptedJson(options.encryptedJson, options.password));
      return _classPrivateFieldGet(this, _ethersWallet).address;
    }
    if ("privateKey" in options) {
      if (!options.encryption && !isValidPrivateKey(options.privateKey)) {
        throw new Error("invalid private key");
      }
      const privateKey = await getDecryptor(options.encryption)(options.privateKey);
      if (options.encryption && (privateKey === "" || !isValidPrivateKey(privateKey))) {
        throw new Error("invalid password");
      }
      _classPrivateFieldSet(this, _ethersWallet, new Wallet(privateKey));
      return _classPrivateFieldGet(this, _ethersWallet).address;
    }
    if ("mnemonic" in options) {
      if (!options.encryption && !utils_exports.isValidMnemonic(options.mnemonic)) {
        throw new Error("invalid mnemonic");
      }
      const mnemonic = await getDecryptor(options.encryption)(options.mnemonic);
      if (options.encryption && (mnemonic === "" || !utils_exports.isValidMnemonic(mnemonic))) {
        throw new Error("invalid password");
      }
      _classPrivateFieldSet(this, _ethersWallet, Wallet.fromMnemonic(mnemonic));
      return _classPrivateFieldGet(this, _ethersWallet).address;
    }
    throw new Error("invalid import strategy");
  }
  async load(options) {
    if (_classPrivateFieldGet(this, _ethersWallet)) {
      throw new Error("wallet is already initialized");
    }
    const walletData = await this.getSavedData(options.storage);
    if (!walletData) {
      throw new Error("No Saved wallet found in storage");
    }
    if (walletData.strategy !== options.strategy) {
      throw new Error(`Saved wallet data is not ${options.strategy}, it is ${walletData.strategy}`);
    }
    if (options.strategy === "encryptedJson") {
      return this.import({
        encryptedJson: walletData.data,
        password: options.password
      });
    }
    if (walletData.isEncrypted && !options.encryption) {
      throw new Error("Saved wallet data is encrypted, but no password is provided");
    }
    if (!walletData.isEncrypted && options.encryption) {
      throw new Error("Saved wallet data is not encrypted, but encryption config is provided");
    }
    if (options.strategy === "privateKey") {
      return this.import({
        privateKey: walletData.data,
        encryption: options.encryption
      });
    }
    if (options.strategy === "mnemonic") {
      return this.import({
        mnemonic: walletData.data,
        encryption: options.encryption
      });
    }
    throw new Error("invalid load strategy");
  }
  async save(options) {
    const wallet = _classPrivateFieldGet(this, _ethersWallet);
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      const encryptedData = await wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: encryptedData,
        strategy: "encryptedJson",
        isEncrypted: true
      }, options.storage);
    }
    if (options.strategy === "privateKey") {
      const privateKey = await getEncryptor(options.encryption)(wallet.privateKey);
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: privateKey,
        strategy: "privateKey",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
    if (options.strategy === "mnemonic") {
      const mnemonic = await getEncryptor(options.encryption)(wallet.mnemonic.phrase);
      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {
        address: wallet.address,
        data: mnemonic,
        strategy: "mnemonic",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
  }
  async isSaved() {
    const data = await this.getSavedData();
    return !!data;
  }
  async deleteSaved() {
    await _classPrivateFieldGet(this, _storage2).removeItem(STORAGE_KEY_WALLET_DATA);
  }
  async export(options) {
    const wallet = _classPrivateFieldGet(this, _ethersWallet);
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      return wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
    }
    if (options.strategy === "privateKey") {
      return getEncryptor(options.encryption)(wallet.privateKey);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key");
      }
      return getEncryptor(options.encryption)(wallet.mnemonic.phrase);
    }
    throw new Error("Invalid export strategy");
  }
  async getSavedData(storage) {
    const _storage = storage || _classPrivateFieldGet(this, _storage2);
    const savedDataStr = await _storage.getItem(STORAGE_KEY_WALLET_DATA);
    if (!savedDataStr) {
      return null;
    }
    try {
      const savedData = JSON.parse(savedDataStr);
      if (!savedData) {
        return null;
      }
      return savedData;
    } catch (e) {
      return null;
    }
  }
};
async function _saveData2(data, storage) {
  const _storage = storage || _classPrivateFieldGet(this, _storage2);
  await _storage.setItem(STORAGE_KEY_WALLET_DATA, JSON.stringify(data));
}
_defineProperty(DeviceWallet, "id", "deviceWallet");
_defineProperty(DeviceWallet, "meta", {
  name: "Device Wallet",
  iconURL: "ipfs://QmcNddbYBuQKiBFnPcxYegjrX6S6z9K1vBNzbBBUJMn2ox/device-wallet.svg"
});
async function defaultEncrypt(message, password) {
  const cryptoJS = (await import("./crypto-js-H6UARXNH.js")).default;
  return cryptoJS.AES.encrypt(message, password).toString();
}
async function defaultDecrypt(message, password) {
  const cryptoJS = (await import("./crypto-js-H6UARXNH.js")).default;
  return cryptoJS.AES.decrypt(message, password).toString(cryptoJS.enc.Utf8);
}
function getDecryptor(encryption) {
  const noop = async (msg) => msg;
  return encryption ? (msg) => (encryption.decrypt || defaultDecrypt)(msg, encryption.password) : noop;
}
function getEncryptor(encryption) {
  const noop = async (msg) => msg;
  return encryption ? (msg) => (encryption.encrypt || defaultEncrypt)(msg, encryption.password) : noop;
}
function isValidPrivateKey(value) {
  return value.match(/^(0x)?[0-9a-f]{64}$/i);
}

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect.browser.esm.js
init_shim();
init_lib();
var TW_WC_PROJECT_ID = "145769e410f16970a79ff77b2d89a1e0";
var _walletConnectConnector = /* @__PURE__ */ new WeakMap();
var _provider = /* @__PURE__ */ new WeakMap();
var _maybeThrowError = /* @__PURE__ */ new WeakMap();
var _onConnect = /* @__PURE__ */ new WeakMap();
var _onDisconnect = /* @__PURE__ */ new WeakMap();
var _onChange = /* @__PURE__ */ new WeakMap();
var _onMessage = /* @__PURE__ */ new WeakMap();
var _onSessionRequestSent = /* @__PURE__ */ new WeakMap();
var _setupListeners = /* @__PURE__ */ new WeakSet();
var _removeListeners = /* @__PURE__ */ new WeakSet();
var WalletConnect = class extends AbstractClientWallet {
  get walletName() {
    return "WalletConnect";
  }
  constructor(options) {
    super((options == null ? void 0 : options.walletId) || WalletConnect.id, options);
    _classPrivateMethodInitSpec(this, _removeListeners);
    _classPrivateMethodInitSpec(this, _setupListeners);
    _classPrivateFieldInitSpec(this, _walletConnectConnector, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _provider, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "projectId", void 0);
    _defineProperty(this, "qrcode", void 0);
    _classPrivateFieldInitSpec(this, _maybeThrowError, {
      writable: true,
      value: (error) => {
        if (error) {
          throw error;
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onConnect, {
      writable: true,
      value: (data) => {
        _classPrivateFieldSet(this, _provider, data.provider);
        if (!_classPrivateFieldGet(this, _provider)) {
          throw new Error("WalletConnect provider not found after connecting.");
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onDisconnect, {
      writable: true,
      value: () => {
        _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);
      }
    });
    _classPrivateFieldInitSpec(this, _onChange, {
      writable: true,
      value: async (payload) => {
        if (payload.chain)
          ;
        else if (payload.account)
          ;
      }
    });
    _classPrivateFieldInitSpec(this, _onMessage, {
      writable: true,
      value: (payload) => {
        switch (payload.type) {
          case "display_uri":
            this.emit("open_wallet", payload.data);
            break;
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onSessionRequestSent, {
      writable: true,
      value: () => {
        this.emit("open_wallet");
      }
    });
    this.projectId = (options == null ? void 0 : options.projectId) || TW_WC_PROJECT_ID;
    this.qrcode = (options == null ? void 0 : options.qrcode) === false ? false : true;
  }
  async getConnector() {
    if (!this.connector) {
      const {
        WalletConnectConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-2WGF32HU.js");
      _classPrivateFieldSet(this, _walletConnectConnector, new WalletConnectConnector({
        chains: this.chains,
        options: {
          qrcode: this.qrcode,
          projectId: this.projectId,
          dappMetadata: this.dappMetadata,
          storage: this.walletStorage
        }
      }));
      this.connector = new WagmiAdapter(_classPrivateFieldGet(this, _walletConnectConnector));
      _classPrivateFieldSet(this, _provider, await _classPrivateFieldGet(this, _walletConnectConnector).getProvider());
      _classPrivateMethodGet(this, _setupListeners, _setupListeners2).call(this);
    }
    return this.connector;
  }
};
function _setupListeners2() {
  var _a;
  if (!_classPrivateFieldGet(this, _walletConnectConnector)) {
    return;
  }
  _classPrivateMethodGet(this, _removeListeners, _removeListeners2).call(this);
  _classPrivateFieldGet(this, _walletConnectConnector).on("connect", _classPrivateFieldGet(this, _onConnect));
  _classPrivateFieldGet(this, _walletConnectConnector).on("disconnect", _classPrivateFieldGet(this, _onDisconnect));
  _classPrivateFieldGet(this, _walletConnectConnector).on("change", _classPrivateFieldGet(this, _onChange));
  _classPrivateFieldGet(this, _walletConnectConnector).on("message", _classPrivateFieldGet(this, _onMessage));
  (_a = _classPrivateFieldGet(this, _provider)) == null ? void 0 : _a.signer.client.on("session_request_sent", _classPrivateFieldGet(this, _onSessionRequestSent));
}
function _removeListeners2() {
  var _a;
  if (!_classPrivateFieldGet(this, _walletConnectConnector)) {
    return;
  }
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("connect", _classPrivateFieldGet(this, _onConnect));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("disconnect", _classPrivateFieldGet(this, _onDisconnect));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("change", _classPrivateFieldGet(this, _onChange));
  _classPrivateFieldGet(this, _walletConnectConnector).removeListener("message", _classPrivateFieldGet(this, _onMessage));
  (_a = _classPrivateFieldGet(this, _provider)) == null ? void 0 : _a.signer.client.removeListener("session_request_sent", _classPrivateFieldGet(this, _onSessionRequestSent));
}
_defineProperty(WalletConnect, "id", "walletConnect");
_defineProperty(WalletConnect, "meta", {
  name: "WalletConnect",
  iconURL: "ipfs://QmX58KPRaTC9JYZ7KriuBzeoEaV2P9eZcA3qbFnTHZazKw/wallet-connect.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/safe/dist/thirdweb-dev-wallets-evm-wallets-safe.browser.esm.js
init_shim();
init_lib();
var import_safe_ethers_adapters = __toESM(require_src());
var import_safe_core_sdk = __toESM(require_src2());
var import_safe_ethers_lib = __toESM(require_src3());
var SafeWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Safe Wallet";
  }
  constructor(options) {
    super(SafeWallet.id, {
      ...options
    });
    _defineProperty(this, "connector", void 0);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SafeConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-safe.browser.esm-UYQG3L6L.js");
      this.connector = new SafeConnector();
    }
    return this.connector;
  }
  async updateChains(chains) {
  }
  async connect(connectOptions) {
    return await super.connect({
      ...connectOptions,
      saveParams: false
    });
  }
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
};
_defineProperty(SafeWallet, "meta", {
  name: "Safe",
  iconURL: "ipfs://QmbbyxDDmmLQh8DzzeUR6X6B75bESsNUFmbdvS3ZsQ2pN1/SafeToken.svg"
});
_defineProperty(SafeWallet, "id", "Safe");

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/wallets/dist/CredentialsStorage-9a5b0621.browser.esm.js
init_shim();

// node_modules/@thirdweb-dev/wallets/evm/wallets/coinbase-wallet/dist/thirdweb-dev-wallets-evm-wallets-coinbase-wallet.browser.esm.js
init_shim();
var import_buffer = __toESM(require_buffer());
init_lib();
{
  window.Buffer = import_buffer.Buffer;
}
var CoinbaseWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Coinbase Wallet";
  }
  constructor(options) {
    super(CoinbaseWallet.id, options);
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "coinbaseConnector", void 0);
    _defineProperty(this, "headlessMode", void 0);
    this.headlessMode = (options == null ? void 0 : options.headlessMode) || false;
  }
  async getConnector() {
    if (!this.connector) {
      const {
        CoinbaseWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-coinbase-wallet.browser.esm-A6OM4WAP.js");
      const cbConnector = new CoinbaseWalletConnector({
        chains: this.chains,
        options: {
          appName: this.dappMetadata.name,
          reloadOnDisconnect: false,
          darkMode: this.dappMetadata.isDarkMode,
          headlessMode: this.headlessMode
        }
      });
      cbConnector.on("connect", () => {
      });
      this.coinbaseConnector = cbConnector;
      this.connector = new WagmiAdapter(cbConnector);
    }
    return this.connector;
  }
  async getQrUrl() {
    await this.getConnector();
    if (!this.coinbaseConnector) {
      throw new Error("Coinbase connector not initialized");
    }
    return this.coinbaseConnector.getQrUrl();
  }
};
_defineProperty(CoinbaseWallet, "meta", {
  iconURL: "ipfs://QmcJBHopbwfJcLqJpX2xEufSS84aLbF7bHavYhaXUcrLaH/coinbase.svg",
  name: "Coinbase Wallet"
});
_defineProperty(CoinbaseWallet, "id", "coinbaseWallet");

// node_modules/@thirdweb-dev/wallets/evm/wallets/injected/dist/thirdweb-dev-wallets-evm-wallets-injected.browser.esm.js
init_shim();
init_lib();
var InjectedWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Injected Wallet";
  }
  constructor(options) {
    super(InjectedWallet.id, options);
    _defineProperty(this, "connector", void 0);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        InjectedConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-injected.browser.esm-QOG22IVV.js");
      this.connector = new WagmiAdapter(new InjectedConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(InjectedWallet, "id", "injected");

// node_modules/@thirdweb-dev/wallets/evm/wallets/metamask/dist/thirdweb-dev-wallets-evm-wallets-metamask.browser.esm.js
init_shim();
init_lib();
var MetaMaskWallet = class extends AbstractClientWallet {
  get walletName() {
    return "MetaMask";
  }
  constructor(options) {
    var _a;
    super(MetaMaskWallet.id, options);
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "walletConnectConnector", void 0);
    _defineProperty(this, "metamaskConnector", void 0);
    _defineProperty(this, "isInjected", void 0);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isMetaMask);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          MetaMaskConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-metamask.browser.esm-G3TY5M7N.js");
        const metamaskConnector = new MetaMaskConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.metamaskConnector = metamaskConnector;
        this.connector = new WagmiAdapter(metamaskConnector);
      } else {
        const {
          WalletConnectV1Connector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect-v1.browser.esm-NTWSYLWR.js");
        const walletConnectConnector = new WalletConnectV1Connector({
          chains: this.chains,
          storage: this.walletStorage,
          options: {
            clientMeta: {
              name: this.dappMetadata.name,
              description: this.dappMetadata.description || "",
              url: this.dappMetadata.url,
              icons: [this.dappMetadata.logoUrl || ""]
            },
            qrcode: (_a = this.options) == null ? void 0 : _a.qrcode
          }
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.connector.on("display_uri", (error, payload) => {
      options.onQrCodeUri(payload.params[0]);
    });
    await wcProvider.enable();
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  async switchAccount() {
    if (!this.metamaskConnector) {
      throw new Error("Can not switch Account");
    }
    await this.metamaskConnector.switchAccount();
  }
};
_defineProperty(MetaMaskWallet, "meta", {
  name: "MetaMask",
  iconURL: "ipfs://QmZZHcw7zcXursywnLDAyY6Hfxzqop5GKgwoq8NB9jjrkN/metamask.svg"
});
_defineProperty(MetaMaskWallet, "id", "metamask");

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect-v1/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect-v1.browser.esm.js
init_shim();
init_lib();
var _walletConnectConnector2 = /* @__PURE__ */ new WeakMap();
var _provider2 = /* @__PURE__ */ new WeakMap();
var _onConnect2 = /* @__PURE__ */ new WeakMap();
var _onDisconnect2 = /* @__PURE__ */ new WeakMap();
var _onChange2 = /* @__PURE__ */ new WeakMap();
var _onMessage2 = /* @__PURE__ */ new WeakMap();
var _setupListeners3 = /* @__PURE__ */ new WeakSet();
var _removeListeners3 = /* @__PURE__ */ new WeakSet();
var WalletConnectV1 = class extends AbstractClientWallet {
  get walletName() {
    var _a;
    return ((_a = _classPrivateFieldGet(this, _walletConnectConnector2)) == null ? void 0 : _a.walletName) || "WalletConnect";
  }
  constructor(options) {
    super((options == null ? void 0 : options.walletId) || WalletConnectV1.id, options);
    _classPrivateMethodInitSpec(this, _removeListeners3);
    _classPrivateMethodInitSpec(this, _setupListeners3);
    _classPrivateFieldInitSpec(this, _walletConnectConnector2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _provider2, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "connector", void 0);
    _defineProperty(this, "qrcode", void 0);
    _classPrivateFieldInitSpec(this, _onConnect2, {
      writable: true,
      value: (data) => {
        _classPrivateFieldSet(this, _provider2, data.provider);
        if (!_classPrivateFieldGet(this, _provider2)) {
          throw new Error("WalletConnect provider not found after connecting.");
        }
      }
    });
    _classPrivateFieldInitSpec(this, _onDisconnect2, {
      writable: true,
      value: () => {
        _classPrivateMethodGet(this, _removeListeners3, _removeListeners22).call(this);
      }
    });
    _classPrivateFieldInitSpec(this, _onChange2, {
      writable: true,
      value: async (payload) => {
        if (payload.chain)
          ;
        else if (payload.account)
          ;
      }
    });
    _classPrivateFieldInitSpec(this, _onMessage2, {
      writable: true,
      value: (payload) => {
        switch (payload.type) {
          case "request":
          case "add_chain":
          case "switch_chain":
            this.emit("open_wallet");
            break;
          case "display_uri":
            this.emit("open_wallet", payload.data);
            break;
        }
      }
    });
    this.qrcode = (options == null ? void 0 : options.qrcode) === false ? false : true;
  }
  async getConnector() {
    if (!this.connector) {
      const {
        WalletConnectV1Connector
      } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect-v1.browser.esm-NTWSYLWR.js");
      _classPrivateFieldSet(this, _walletConnectConnector2, new WalletConnectV1Connector({
        chains: this.chains,
        storage: this.walletStorage,
        options: {
          qrcode: this.qrcode,
          clientMeta: {
            description: this.dappMetadata.description || "",
            url: this.dappMetadata.url,
            icons: [this.dappMetadata.logoUrl || ""],
            name: this.dappMetadata.name
          }
        }
      }));
      this.connector = new WagmiAdapter(_classPrivateFieldGet(this, _walletConnectConnector2));
      _classPrivateFieldSet(this, _provider2, await _classPrivateFieldGet(this, _walletConnectConnector2).getProvider());
      _classPrivateMethodGet(this, _setupListeners3, _setupListeners22).call(this);
    }
    return this.connector;
  }
};
function _setupListeners22() {
  if (!_classPrivateFieldGet(this, _walletConnectConnector2)) {
    return;
  }
  _classPrivateFieldGet(this, _walletConnectConnector2).on("connect", _classPrivateFieldGet(this, _onConnect2));
  _classPrivateFieldGet(this, _walletConnectConnector2).on("disconnect", _classPrivateFieldGet(this, _onDisconnect2));
  _classPrivateFieldGet(this, _walletConnectConnector2).on("change", _classPrivateFieldGet(this, _onChange2));
  _classPrivateFieldGet(this, _walletConnectConnector2).on("message", _classPrivateFieldGet(this, _onMessage2));
}
function _removeListeners22() {
  if (!_classPrivateFieldGet(this, _walletConnectConnector2)) {
    return;
  }
  _classPrivateFieldGet(this, _walletConnectConnector2).removeListener("connect", _classPrivateFieldGet(this, _onConnect2));
  _classPrivateFieldGet(this, _walletConnectConnector2).removeListener("disconnect", _classPrivateFieldGet(this, _onDisconnect2));
  _classPrivateFieldGet(this, _walletConnectConnector2).removeListener("change", _classPrivateFieldGet(this, _onChange2));
  _classPrivateFieldGet(this, _walletConnectConnector2).removeListener("message", _classPrivateFieldGet(this, _onMessage2));
}
_defineProperty(WalletConnectV1, "id", "walletConnectV1");
_defineProperty(WalletConnectV1, "meta", {
  name: "WalletConnect",
  iconURL: "ipfs://QmX58KPRaTC9JYZ7KriuBzeoEaV2P9eZcA3qbFnTHZazKw/wallet-connect.svg"
});

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_lib();
var import_buffer2 = __toESM(require_buffer());
var import_safe_ethers_adapters2 = __toESM(require_src());
var import_safe_core_sdk2 = __toESM(require_src2());
var import_safe_ethers_lib2 = __toESM(require_src3());

export {
  createAsyncLocalStorage,
  PaperWallet,
  CoinbaseWallet,
  DeviceWallet,
  MetaMaskWallet,
  WalletConnect,
  WalletConnectV1,
  SafeWallet
};
//# sourceMappingURL=chunk-AUSOLY5I.js.map
