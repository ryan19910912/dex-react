{
  "version": 3,
  "sources": ["../../@paperxyz/sdk-common-utilities/src/constants/blockchain.ts", "../../@paperxyz/sdk-common-utilities/src/constants/settings.ts", "../../@paperxyz/sdk-common-utilities/src/constants/style.ts", "../../@paperxyz/embedded-wallet-service-sdk/src/constants/settings.ts", "../../@paperxyz/embedded-wallet-service-sdk/src/interfaces/Auth.ts", "../../@paperxyz/embedded-wallet-service-sdk/src/interfaces/EmbeddedWallets/EmbeddedWallets.ts", "../../@paperxyz/embedded-wallet-service-sdk/src/utils/iFrameCommunication/EmbeddedWalletIframeCommunicator.ts", "../../@paperxyz/embedded-wallet-service-sdk/src/utils/Storage/LocalStorage.ts", "../../@paperxyz/embedded-wallet-service-sdk/src/utils/iFrameCommunication/IframeCommunicator.ts", "../../@paperxyz/embedded-wallet-service-sdk/src/lib/Auth.ts", "../../@paperxyz/embedded-wallet-service-sdk/src/lib/EmbeddedWallets/EmbeddedWallet.ts", "../../@paperxyz/embedded-wallet-service-sdk/src/lib/EmbeddedWallets/GaslessTransactionMaker.ts", "../../@paperxyz/embedded-wallet-service-sdk/src/lib/EmbeddedWallets/Signer.ts", "../../@paperxyz/embedded-wallet-service-sdk/src/lib/Paper.ts"],
  "sourcesContent": ["export const ChainToPublicRpc: Record<Chain, string> = {\n  Ethereum: \"https://rpc.ankr.com/eth\",\n  Goerli: \"https://goerli.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161\",\n  Mumbai: \"https://rpc-mumbai.maticvigil.com\",\n  Polygon: \"https://rpc-mainnet.maticvigil.com\",\n  Avalanche: \"https://api.avax.network/ext/bc/C/rpc\",\n};\n\n// General Embedded wallet types\nexport type Chain = \"Polygon\" | \"Mumbai\" | \"Goerli\" | \"Ethereum\" | \"Avalanche\";\n\nexport type SupportedChainName = Chain | \"Rinkeby\" | \"Solana\" | \"SolanaDevnet\";\n", "const isDev = (): boolean => {\n  return !!(\n    typeof window !== \"undefined\" &&\n    window.localStorage.getItem(\"IS_PAPER_DEV\") === \"true\"\n  );\n};\n\nconst isOldPaperDomain = (): boolean =>\n  typeof window !== \"undefined\" && window.location.origin.includes(\"paper.xyz\");\n\nexport const getPaperOriginUrl = (): string => {\n  if (isDev())\n    return (\n      window.localStorage.getItem(\"PAPER_DEV_URL\") ?? \"http://localhost:3000\"\n    );\n\n  if (isOldPaperDomain()) return window.location.origin;\n\n  return \"https://withpaper.com\";\n};\n", "export type StyleObject = Partial<CSSStyleDeclaration>;\n\nexport interface ICustomizationOptions {\n  colorPrimary?: string;\n  colorBackground?: string;\n  colorText?: string;\n  borderRadius?: number;\n  fontFamily?: string;\n\n  inputBackgroundColor?: string;\n  inputBorderColor?: string;\n}\nexport type CustomizationOptionsType = {\n  [key in keyof ICustomizationOptions]: string;\n};\nexport type Locale = \"en\" | \"fr\" | \"es\" | \"it\" | \"de\" | \"ja\" | \"ko\" | \"zh\";\n\nexport const DEFAULT_BRAND_OPTIONS = {\n  colorPrimary: \"#cf3781\",\n  colorBackground: \"#ffffff\",\n  colorText: \"#1a202c\",\n  borderRadius: 12,\n  fontFamily: \"Open Sans\",\n};\n", "export const EMBEDDED_WALLET_PATH = \"/sdk/2022-08-12/embedded-wallet\";\n\nexport const WALLET_USER_ID_LOCAL_STORAGE_NAME = (clientId: string) =>\n  `paperEwsWalletUserId-${clientId}`;\nconst AUTH_TOKEN_LOCAL_STORAGE_PREFIX = \"walletToken\";\nexport const AUTH_TOKEN_LOCAL_STORAGE_NAME = (clientId: string) => {\n  return `${AUTH_TOKEN_LOCAL_STORAGE_PREFIX}-${clientId}`;\n};\nconst DEVICE_SHARE_LOCAL_STORAGE_PREFIX = \"a\";\nexport const DEVICE_SHARE_LOCAL_STORAGE_NAME = (\n  clientId: string,\n  userId: string,\n) => `${DEVICE_SHARE_LOCAL_STORAGE_PREFIX}-${clientId}-${userId}`;\nexport const DEVICE_SHARE_LOCAL_STORAGE_NAME_DEPRECATED = (clientId: string) =>\n  `${DEVICE_SHARE_LOCAL_STORAGE_PREFIX}-${clientId}`;\n", "import type {\n  AuthDetails,\n  InitializedUser,\n  SetUpWalletRpcReturnType,\n} from \"./EmbeddedWallets/EmbeddedWallets\";\n\nexport enum AuthProvider {\n  PAPER_EMAIL_OTP = \"PaperEmailOTP\",\n  GOOGLE = \"Google\",\n  AUTH0 = \"Auth0\",\n  CUSTOM_JWT = \"CustomJWT\",\n}\n\nexport type GetSocialLoginClientIdReturnType = {\n  clientId: string;\n};\n\n// TODO: Clean up tech debt of random type Objects\n// E.g. StoredTokenType is really not used anywhere but it exists as this object for legacy reason\nexport type StoredTokenType = {\n  jwtToken: string;\n  authProvider: AuthProvider;\n  authDetails: AuthDetails;\n  developerClientId: string;\n};\n\nexport type AuthStoredTokenWithCookieReturnType = {\n  storedToken: StoredTokenType & {\n    cookieString: string;\n    shouldStoreCookieString: boolean;\n    isNewUser: boolean;\n  };\n};\nexport type AuthAndWalletRpcReturnType = AuthStoredTokenWithCookieReturnType & {\n  walletDetails: SetUpWalletRpcReturnType;\n};\n\nexport type AuthLoginReturnType = { user: InitializedUser };\n", "import type {\n  Chain,\n  CustomizationOptionsType,\n} from \"@paperxyz/sdk-common-utilities\";\nimport type { EmbeddedWallet } from \"../../lib/EmbeddedWallets/EmbeddedWallet\";\nimport type { EmbeddedWalletIframeCommunicator } from \"../../utils/iFrameCommunication/EmbeddedWalletIframeCommunicator\";\n\n// Class constructor types\n// types for class constructors still a little messy right now.\n// Open to PRs from whoever sees this and knows of a cleaner way to handle things\nexport type ClientIdConstructorType = { clientId: string };\nexport type PaperConstructorType = ClientIdConstructorType & {\n  chain: Chain;\n  styles?: CustomizationOptionsType;\n};\nexport type ClientIdWithQuerierType = ClientIdConstructorType & {\n  querier: EmbeddedWalletIframeCommunicator<any>;\n};\nexport type ClientIdWithQuerierAndChainType = ClientIdWithQuerierType & {\n  chain: Chain;\n};\n\n// Auth Types\nexport type AuthDetails = { email: string; userWalletId: string };\n\nexport type InitializedUser = {\n  status: UserStatus.LOGGED_IN_WALLET_INITIALIZED;\n  wallet: EmbeddedWallet;\n  walletAddress: string;\n  authDetails: AuthDetails;\n};\n\n// Embedded Wallet Types\nexport enum UserStatus {\n  LOGGED_OUT = \"Logged Out\",\n  LOGGED_IN_WALLET_INITIALIZED = \"Logged In, Wallet Initialized\",\n}\nexport enum UserWalletStatus {\n  LOGGED_OUT = \"Logged Out\",\n  LOGGED_IN_WALLET_UNINITIALIZED = \"Logged In, Wallet Uninitialized\",\n  LOGGED_IN_NEW_DEVICE = \"Logged In, New Device\",\n  LOGGED_IN_WALLET_INITIALIZED = \"Logged In, Wallet Initialized\",\n}\n\nexport type WalletAddressObjectType = {\n  walletAddress: string;\n};\nexport type SetUpWalletReturnType = WalletAddressObjectType & {\n  initialUserStatus: UserWalletStatus;\n};\nexport type SetUpWalletRpcReturnType = WalletAddressObjectType & {\n  deviceShareStored: string;\n  isIframeStorageEnabled: boolean;\n};\n\nexport type SendEmailOtpReturnType = {\n  isNewUser: boolean;\n  isNewDevice: boolean;\n};\nexport type LogoutReturnType = { success: boolean };\nexport type GetAuthDetailsReturnType = { authDetails?: AuthDetails };\n\n// ! Types seem repetitive, but the name should identify which goes where\n// this is the return type from the EmbeddedWallet Class getUserWalletStatus method iframe call\nexport type GetUserWalletStatusRpcReturnType =\n  | {\n      status: UserWalletStatus.LOGGED_OUT;\n      user: undefined;\n    }\n  | {\n      status: UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED;\n      user: { authDetails: AuthDetails };\n    }\n  | {\n      status: UserWalletStatus.LOGGED_IN_NEW_DEVICE;\n      user: { authDetails: AuthDetails; walletAddress: string };\n    }\n  | {\n      status: UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED;\n      user: Omit<InitializedUser, \"wallet\" | \"status\">;\n    };\n\n// this is the return type from the EmbeddedWallet Class getUserWalletStatus method\nexport type GetUserWalletStatusFnReturnType =\n  | {\n      status: UserWalletStatus.LOGGED_OUT;\n      user: undefined;\n    }\n  | {\n      status: UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED;\n      user: { authDetails: AuthDetails };\n    }\n  | {\n      status: UserWalletStatus.LOGGED_IN_NEW_DEVICE;\n      user: { authDetails: AuthDetails; walletAddress: string };\n    }\n  | {\n      status: UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED;\n      user: Omit<InitializedUser, \"status\">;\n    };\n\n// This is returned from the getUser method in PaperEmbeddedWalletSdk\nexport type GetUser =\n  | {\n      status: UserStatus.LOGGED_OUT;\n    }\n  | InitializedUser;\n", "import type { CustomizationOptionsType } from \"@paperxyz/sdk-common-utilities\";\nimport { getPaperOriginUrl } from \"@paperxyz/sdk-common-utilities\";\nimport { EMBEDDED_WALLET_PATH } from \"../../constants/settings\";\nimport { LocalStorage } from \"../Storage/LocalStorage\";\nimport { IframeCommunicator } from \"./IframeCommunicator\";\n\nexport class EmbeddedWalletIframeCommunicator<\n  T extends { [key: string]: any },\n> extends IframeCommunicator<T> {\n  clientId: string;\n  constructor({\n    clientId,\n    customizationOptions,\n  }: {\n    clientId: string;\n    customizationOptions?: CustomizationOptionsType;\n  }) {\n    super({\n      iframeId: EMBEDDED_WALLET_IFRAME_ID,\n      link: createEmbeddedWalletIframeLink({\n        clientId,\n        path: EMBEDDED_WALLET_PATH,\n        queryParams: customizationOptions,\n      }).href,\n      container: document.body,\n    });\n    this.clientId = clientId;\n  }\n\n  override async onIframeLoadedInitVariables() {\n    const localStorage = new LocalStorage({\n      clientId: this.clientId,\n    });\n\n    return {\n      authCookie: await localStorage.getAuthCookie(),\n      deviceShareStored: await localStorage.getDeviceShare(),\n      walletUserId: await localStorage.getWalletUserId(),\n      clientId: this.clientId,\n    };\n  }\n}\n\n// This is the URL and ID tag of the iFrame that we communicate with\nexport function createEmbeddedWalletIframeLink({\n  clientId,\n  path,\n  queryParams,\n}: {\n  clientId: string;\n  path: string;\n  queryParams?: { [key: string]: string | number };\n}) {\n  const embeddedWalletUrl = new URL(path, getPaperOriginUrl());\n  embeddedWalletUrl.searchParams.set(\"clientId\", clientId);\n  if (queryParams) {\n    for (const queryKey of Object.keys(queryParams)) {\n      embeddedWalletUrl.searchParams.set(\n        queryKey,\n        queryParams[queryKey]?.toString() || \"\",\n      );\n    }\n  }\n  return embeddedWalletUrl;\n}\nexport const EMBEDDED_WALLET_IFRAME_ID = \"paper-embedded-wallet-iframe\";\n", "import {\n  AUTH_TOKEN_LOCAL_STORAGE_NAME,\n  DEVICE_SHARE_LOCAL_STORAGE_NAME,\n  WALLET_USER_ID_LOCAL_STORAGE_NAME,\n} from \"../../constants/settings\";\n\nconst data = new Map<string, string>();\n\nexport class LocalStorage {\n  protected isSupported: boolean;\n  protected clientId: string;\n  constructor({ clientId }: { clientId: string }) {\n    this.isSupported = typeof window !== \"undefined\" && !!window.localStorage;\n    this.clientId = clientId;\n  }\n\n  protected async getItem(key: string): Promise<string | null> {\n    if (this.isSupported) {\n      return window.localStorage.getItem(key);\n    } else {\n      return data.get(key) ?? null;\n    }\n  }\n\n  protected async setItem(key: string, value: string): Promise<void> {\n    if (this.isSupported) {\n      return window.localStorage.setItem(key, value);\n    } else {\n      data.set(key, value);\n    }\n  }\n\n  protected async removeItem(key: string): Promise<boolean> {\n    const item = await this.getItem(key);\n    if (this.isSupported && item) {\n      window.localStorage.removeItem(key);\n      return true;\n    }\n    return false;\n  }\n\n  async saveAuthCookie(cookie: string): Promise<void> {\n    await this.setItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId), cookie);\n  }\n  async getAuthCookie(): Promise<string | null> {\n    return this.getItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId));\n  }\n  async removeAuthCookie(): Promise<boolean> {\n    return this.removeItem(AUTH_TOKEN_LOCAL_STORAGE_NAME(this.clientId));\n  }\n\n  async saveDeviceShare(share: string, userId: string): Promise<void> {\n    await this.saveWalletUserId(userId);\n    await this.setItem(\n      DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId),\n      share,\n    );\n  }\n  async getDeviceShare(): Promise<string | null> {\n    const userId = await this.getWalletUserId();\n    if (userId) {\n      return this.getItem(\n        DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId),\n      );\n    }\n    return null;\n  }\n  async removeDeviceShare(): Promise<boolean> {\n    const userId = await this.getWalletUserId();\n    if (userId) {\n      return this.removeItem(\n        DEVICE_SHARE_LOCAL_STORAGE_NAME(this.clientId, userId),\n      );\n    }\n    return false;\n  }\n\n  async getWalletUserId(): Promise<string | null> {\n    return this.getItem(WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId));\n  }\n  async saveWalletUserId(userId: string): Promise<void> {\n    await this.setItem(\n      WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId),\n      userId,\n    );\n  }\n  async removeWalletUserId(): Promise<boolean> {\n    return this.removeItem(WALLET_USER_ID_LOCAL_STORAGE_NAME(this.clientId));\n  }\n}\n", "import type { MessageType, StyleObject } from \"@paperxyz/sdk-common-utilities\";\nimport { getPaperOriginUrl } from \"@paperxyz/sdk-common-utilities\";\nimport { EMBEDDED_WALLET_PATH } from \"../../constants/settings\";\n\ntype IFrameCommunicatorProps = {\n  link: string;\n  iframeId: string;\n  container?: HTMLElement;\n  iframeStyles?: StyleObject;\n  onIframeInitialize?: () => void;\n};\n\nfunction sleep(seconds: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, seconds * 1000);\n  });\n}\n\nconst iframeBaseStyle = {\n  height: \"100%\",\n  width: \"100%\",\n  border: \"none\",\n  backgroundColor: \"transparent\",\n  position: \"fixed\",\n  top: \"0px\",\n  right: \"0px\",\n  zIndex: \"2147483646\",\n  display: \"none\",\n};\n\n// Global var to help track iframe state\nconst isIframeLoaded = new Map<string, boolean>();\n\nexport class IframeCommunicator<T extends { [key: string]: any }> {\n  private iframe: HTMLIFrameElement;\n  private POLLING_INTERVAL_SECONDS = 1.4;\n  private POST_LOAD_BUFFER_SECONDS = 1;\n\n  constructor({\n    link,\n    iframeId,\n    container = document.body,\n    iframeStyles,\n    onIframeInitialize,\n  }: IFrameCommunicatorProps) {\n    // Creating the IFrame element for communication\n    let iframe = document.getElementById(iframeId) as HTMLIFrameElement | null;\n    const hrefLink = new URL(link);\n    const sdkVersion = process.env.SDK_VERSION;\n    if (!sdkVersion) {\n      throw new Error(\"Missing SDK_VERSION env var\");\n    }\n    hrefLink.searchParams.set(\"sdkVersion\", sdkVersion);\n    if (!iframe || iframe.src != hrefLink.href) {\n      // ! Do not update the hrefLink here or it'll cause multiple re-renders\n      if (!iframe) {\n        iframe = document.createElement(\"iframe\");\n        const mergedIframeStyles = {\n          ...iframeBaseStyle,\n          ...iframeStyles,\n        };\n        Object.assign(iframe.style, mergedIframeStyles);\n        iframe.setAttribute(\"id\", iframeId);\n        container.appendChild(iframe);\n      }\n      iframe.src = hrefLink.href;\n      iframe.setAttribute(\"data-version\", sdkVersion);\n      iframe.onload = this.onIframeLoadHandler(\n        iframe,\n        this.POST_LOAD_BUFFER_SECONDS,\n        onIframeInitialize,\n      );\n    }\n    this.iframe = iframe;\n  }\n\n  protected async onIframeLoadedInitVariables(): Promise<Record<string, any>> {\n    return {};\n  }\n\n  onIframeLoadHandler(\n    iframe: HTMLIFrameElement,\n    prePostMessageSleepInSeconds: number,\n    onIframeInitialize?: () => void,\n  ) {\n    return async () => {\n      const promise = new Promise<boolean>(async (res, rej) => {\n        const channel = new MessageChannel();\n        channel.port1.onmessage = (event: MessageEvent<MessageType<void>>) => {\n          const { data } = event;\n          channel.port1.close();\n          if (!data.success) {\n            return rej(data.error);\n          }\n          isIframeLoaded.set(iframe.src, true);\n          if (onIframeInitialize) {\n            onIframeInitialize();\n          }\n          return res(true);\n        };\n        // iFrame takes a bit of time after loading to be ready for message receiving\n        // This is hacky\n        await sleep(prePostMessageSleepInSeconds);\n        const INIT_IFRAME_EVENT = \"initIframe\";\n        iframe?.contentWindow?.postMessage(\n          // ? We initialise the iframe with a bunch\n          // of useful information so that we don't have to pass it\n          // through in each of the future call. This would be where we do it.\n          {\n            eventType: INIT_IFRAME_EVENT,\n            data: await this.onIframeLoadedInitVariables(),\n          },\n          `${getPaperOriginUrl()}${EMBEDDED_WALLET_PATH}`,\n          [channel.port2],\n        );\n      });\n      await promise;\n    };\n  }\n\n  async call<ReturnData>({\n    procedureName,\n    params,\n    showIframe = false,\n  }: {\n    procedureName: keyof T;\n    params: T[keyof T];\n    showIframe?: boolean;\n  }) {\n    while (!isIframeLoaded.get(this.iframe.src)) {\n      await sleep(this.POLLING_INTERVAL_SECONDS);\n    }\n    if (showIframe) {\n      this.iframe.style.display = \"block\";\n      // magic number to let the display render before performing the animation of the modal in\n      await sleep(0.005);\n    }\n    const promise = new Promise<ReturnData>((res, rej) => {\n      const channel = new MessageChannel();\n      channel.port1.onmessage = async (\n        event: MessageEvent<MessageType<ReturnData>>,\n      ) => {\n        const { data } = event;\n        channel.port1.close();\n        if (showIframe) {\n          // magic number to let modal fade out before hiding it\n          await sleep(0.1);\n          this.iframe.style.display = \"none\";\n        }\n        if (!data.success) {\n          rej(data.error);\n        } else {\n          res(data.data);\n        }\n      };\n      this.iframe.contentWindow?.postMessage(\n        { eventType: procedureName, data: params },\n        `${getPaperOriginUrl()}${EMBEDDED_WALLET_PATH}`,\n        [channel.port2],\n      );\n    });\n    return promise;\n  }\n\n  /**\n   * This has to be called by any iframe that will be removed from the DOM.\n   * Use to make sure that we reset the global loaded state of the particular iframe.src\n   */\n  destroy() {\n    isIframeLoaded.delete(this.iframe.src);\n  }\n}\n", "import type {\n  AuthAndWalletRpcReturnType,\n  AuthLoginReturnType,\n  AuthProvider,\n} from \"../interfaces/Auth\";\nimport type {\n  ClientIdWithQuerierType,\n  LogoutReturnType,\n  SendEmailOtpReturnType,\n} from \"../interfaces/EmbeddedWallets/EmbeddedWallets\";\nimport type { EmbeddedWalletIframeCommunicator } from \"../utils/iFrameCommunication/EmbeddedWalletIframeCommunicator\";\nimport { LocalStorage } from \"../utils/Storage/LocalStorage\";\n\nexport type AuthQuerierTypes = {\n  loginWithJwtAuthCallback: {\n    token: string;\n    authProvider: AuthProvider;\n    recoveryCode?: string;\n  };\n  loginWithPaperModal: void | { email: string };\n  logout: void;\n  sendPaperEmailLoginOtp: { email: string };\n  verifyPaperEmailLoginOtp: {\n    email: string;\n    otp: string;\n    recoveryCode?: string;\n  };\n};\n\nexport class Auth {\n  protected clientId: string;\n  protected AuthQuerier: EmbeddedWalletIframeCommunicator<AuthQuerierTypes>;\n  protected localStorage: LocalStorage;\n  protected onAuthSuccess: (\n    authResults: AuthAndWalletRpcReturnType,\n  ) => Promise<AuthLoginReturnType>;\n\n  /**\n   * Used to manage the user's auth states. This should not be instantiated directly.\n   * Call {@link PaperEmbeddedWalletSdk.auth} instead.\n   *\n   * Authentication settings can be managed via the [authentication settings dashboard](https://withpaper.com/dashboard/auth-settings)\n   * @param {string} params.clientId the clientId associated with the various authentication settings\n   */\n  constructor({\n    clientId,\n    querier,\n    onAuthSuccess,\n  }: ClientIdWithQuerierType & {\n    onAuthSuccess: (\n      authDetails: AuthAndWalletRpcReturnType,\n    ) => Promise<AuthLoginReturnType>;\n  }) {\n    this.clientId = clientId;\n    this.AuthQuerier = querier;\n    this.localStorage = new LocalStorage({ clientId });\n    this.onAuthSuccess = onAuthSuccess;\n  }\n\n  private async postLogin({\n    storedToken,\n    walletDetails,\n  }: AuthAndWalletRpcReturnType): Promise<AuthLoginReturnType> {\n    if (storedToken.shouldStoreCookieString) {\n      await this.localStorage.saveAuthCookie(storedToken.cookieString);\n    }\n    const initializedUser = await this.onAuthSuccess({\n      storedToken,\n      walletDetails,\n    });\n    return initializedUser;\n  }\n\n  /**\n   * @description\n   * Used to log the user in with an oauth login flow\n   *\n   * Note that you have to either enable \"Auth0\" or \"Custom JSON Web Token\" in the [auth setting dashboard](https://withpaper.com/dashboard/auth-settings) in order to use this\n   * @param {string} jwtParams.token The associate token from the oauth callback\n   * @param {AuthProvider} jwtParams.provider The Auth provider that is being used\n   * @param {string} jwtParams.recoveryCode This has to be passed in if the user is not logging in for the first time in order for us to decrypt and recover the users wallet\n   * @returns {{user: InitializedUser}} An InitializedUser object containing the user's status, wallet, authDetails, and more\n   */\n  async loginWithJwtAuth({\n    token,\n    authProvider,\n    recoveryCode,\n  }: AuthQuerierTypes[\"loginWithJwtAuthCallback\"]): Promise<AuthLoginReturnType> {\n    const result = await this.AuthQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithJwtAuthCallback\",\n      params: {\n        token,\n        authProvider,\n        recoveryCode,\n      },\n    });\n    return this.postLogin(result);\n  }\n\n  /**\n   * @description\n   * Used to log the user into their Paper wallet on your platform via a myriad of auth providers\n   *\n   * @example\n   * const Paper = new PaperEmbeddedWalletSdk({clientId: \"YOUR_CLIENT_ID\", chain: \"Polygon\"})\n   * try {\n   *   const user = await Paper.auth.loginWithPaperModal();\n   *   // user is now logged in\n   * } catch (e) {\n   *   // User closed modal or something else went wrong during the authentication process\n   *   console.error(e)\n   * }\n   *\n   * @returns {{user: InitializedUser}} An InitializedUser object. See {@link PaperEmbeddedWalletSdk.getUser} for more\n   */\n  async loginWithPaperModal(): Promise<AuthLoginReturnType> {\n    const result = await this.AuthQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithPaperModal\",\n      params: undefined,\n      showIframe: true,\n    });\n    return this.postLogin(result);\n  }\n\n  /**\n   * @description\n   * Used to log the user into their Paper wallet using email OTP\n   *\n   * @example\n   *  const Paper = new PaperEmbeddedWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   *  try {\n   *    // prompts user to enter the code they received\n   *    const user = await Paper.auth.loginWithPaperEmailOtp({ email : \"you@example.com\" });\n   *    // user is now logged in\n   *  } catch (e) {\n   *    // User closed the OTP modal or something else went wrong during the authentication process\n   *    console.error(e)\n   *  }\n   * @param {string} props.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @returns {{user: InitializedUser}} An InitializedUser object. See {@link PaperEmbeddedWalletSdk.getUser} for more\n   */\n  async loginWithPaperEmailOtp({\n    email,\n  }: {\n    email: string;\n  }): Promise<AuthLoginReturnType> {\n    const result = await this.AuthQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithPaperModal\",\n      params: { email },\n      showIframe: true,\n    });\n    return this.postLogin(result);\n  }\n\n  /**\n   * @description\n   * A headless way to send the users at {email} an OTP code.\n   * You need to then call {@link Auth.verifyPaperEmailLoginOtp} in order to complete the login process\n   *\n   * @example\n   *  const Paper = new PaperEmbeddedWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   *  // sends user an OTP code\n   * try {\n   *    const { isNewUser } = await Paper.auth.sendPaperEmailLoginOtp({ email : \"you@example.com\" });\n   * } catch(e) {\n   *    // Error Sending user's email an OTP code\n   *    console.error(e);\n   * }\n   *\n   * // Then when your user is ready to verify their OTP\n   * try {\n   *    const user = await Paper.auth.verifyPaperEmailLoginOtp({ email: \"you@example.com\", otp: \"6-DIGIT_CODE_HERE\", recoveryCode: \"Required if user is an existing user. i.e. !isNewUser\"});\n   * } catch(e) {\n   *    // Error verifying the OTP code\n   *    console.error(e)\n   * }\n   *\n   * @param {string} props.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @returns {{ success: boolean, isNewUser: boolean }} Success: indicating if the email was successfully sent (Note the email could still end up in the user's spam folder). IsNewUser indicates if the user is a new user to your platform\n   */\n  async sendPaperEmailLoginOtp({\n    email,\n  }: AuthQuerierTypes[\"sendPaperEmailLoginOtp\"]): Promise<SendEmailOtpReturnType> {\n    const { isNewUser, isNewDevice } =\n      await this.AuthQuerier.call<SendEmailOtpReturnType>({\n        procedureName: \"sendPaperEmailLoginOtp\",\n        params: { email },\n      });\n    return { isNewUser, isNewDevice };\n  }\n\n  /**\n   *  @description\n   * Used to verify the otp that the user receives from  Paper\n   *\n   * See {@link Auth.sendPaperEmailLoginOtp} for how the headless call flow looks like\n   *\n   * @param {string} props.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @param {string} props.otp The code that the user received in their email\n   * @param {string} props.recoveryCode The code that is first sent to the user when they sign up. Required if user is an existing user. i.e. !isNewUser from return params of {@link Auth.sendPaperEmailLoginOtp}\n   * @returns {{user: InitializedUser}} An InitializedUser object containing the user's status, wallet, authDetails, and more\n   */\n  async verifyPaperEmailLoginOtp({\n    email,\n    otp,\n    recoveryCode,\n  }: AuthQuerierTypes[\"verifyPaperEmailLoginOtp\"]) {\n    const result = await this.AuthQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"verifyPaperEmailLoginOtp\",\n      params: { email, otp, recoveryCode },\n    });\n    return this.postLogin(result);\n  }\n\n  /**\n   * @description\n   * Logs any existing user out of their wallet.\n   * @returns {{success: boolean}} true if a user is successfully logged out. false if there's no user currently logged in.\n   */\n  async logout(): Promise<LogoutReturnType> {\n    const { success } = await this.AuthQuerier.call<LogoutReturnType>({\n      procedureName: \"logout\",\n      params: undefined,\n    });\n    const isRemoveAuthCookie = await this.localStorage.removeAuthCookie();\n    const isRemoveUserId = await this.localStorage.removeWalletUserId();\n\n    return {\n      success: success || isRemoveAuthCookie || isRemoveUserId,\n    };\n  }\n}\n", "import type { Networkish } from \"@ethersproject/providers\";\nimport { getDefaultProvider } from \"@ethersproject/providers\";\nimport type { Chain } from \"@paperxyz/sdk-common-utilities\";\nimport { ChainToPublicRpc } from \"@paperxyz/sdk-common-utilities\";\nimport type {\n  ClientIdWithQuerierAndChainType,\n  GetUserWalletStatusFnReturnType,\n  GetUserWalletStatusRpcReturnType,\n  SetUpWalletRpcReturnType,\n  WalletAddressObjectType,\n} from \"../../interfaces/EmbeddedWallets/EmbeddedWallets\";\nimport { UserWalletStatus } from \"../../interfaces/EmbeddedWallets/EmbeddedWallets\";\n\nimport type { EmbeddedWalletIframeCommunicator } from \"../../utils/iFrameCommunication/EmbeddedWalletIframeCommunicator\";\nimport { LocalStorage } from \"../../utils/Storage/LocalStorage\";\nimport { GaslessTransactionMaker } from \"./GaslessTransactionMaker\";\nimport { EthersSigner } from \"./Signer\";\n\nexport type WalletManagementTypes = {\n  createWallet: void;\n  setUpNewDevice: void;\n  getUserStatus: void;\n};\nexport type WalletManagementUiTypes = {\n  createWalletUi: void;\n  setUpNewDeviceUi: void;\n};\n\nexport type EmbeddedWalletInternalHelperType = { showUi: boolean };\n\nexport class EmbeddedWallet {\n  protected clientId: string;\n  protected chain: Chain;\n  protected walletManagerQuerier: EmbeddedWalletIframeCommunicator<\n    WalletManagementTypes & WalletManagementUiTypes\n  >;\n  protected localStorage: LocalStorage;\n\n  public gasless: GaslessTransactionMaker;\n\n  /**\n   * Not meant to be initialized directly. Call {@link .initializeUser} to get an instance\n   * @param param0\n   */\n  constructor({ clientId, chain, querier }: ClientIdWithQuerierAndChainType) {\n    this.clientId = clientId;\n    this.chain = chain;\n    this.walletManagerQuerier = querier;\n\n    this.gasless = new GaslessTransactionMaker({\n      chain,\n      clientId,\n      querier,\n    });\n\n    this.localStorage = new LocalStorage({ clientId });\n  }\n\n  /**\n   * @internal\n   * Used to set-up the user device in the case that they are using incognito\n   * @param {string} param.deviceShareStored the value that is saved for the user's device share.\n   * We save this into the localStorage on the site itself if we could not save it within the iframe's localStorage.\n   * This happens in incognito mostly\n   * @param {string} param.walletAddress User's wallet address\n   * @param {boolean} param.isIframeStorageEnabled Tells us if we were able to store values in the localStorage in our iframe.\n   * We need to store it under the dev's domain localStorage if we weren't able to store things in the iframe\n   * @returns {{ walletAddress : string }} The user's wallet details\n   */\n  async postWalletSetUp({\n    deviceShareStored,\n    walletAddress,\n    isIframeStorageEnabled,\n    walletUserId,\n  }: SetUpWalletRpcReturnType & {\n    walletUserId: string;\n  }): Promise<WalletAddressObjectType> {\n    if (!isIframeStorageEnabled) {\n      await this.localStorage.saveDeviceShare(deviceShareStored, walletUserId);\n    }\n    return { walletAddress };\n  }\n\n  /**\n   * @internal\n   * Gets the various status states of the user\n   * @example\n   *  const userStatus = await Paper.getUserWalletStatus();\n   *  switch (userStatus.status) {\n   *  case UserWalletStatus.LOGGED_OUT: {\n   *    // User is logged out, call one of the auth methods on Paper.auth to authenticate the user\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED: {\n   *    // User is logged in, but does not have a wallet associated with it\n   *    // you also have access to the user's details\n   *    userStatus.user.authDetails;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_NEW_DEVICE: {\n   *    // User is logged in and created a wallet already, but is missing the device shard\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *    // user is logged in and wallet is all set up.\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    userStatus.user.wallet;\n   *    break;\n   *  }\n   *}\n   * @returns {GetUserWalletStatusFnReturnType} an object to containing various information on the user statuses\n   */\n  async getUserWalletStatus(): Promise<GetUserWalletStatusFnReturnType> {\n    const userStatus =\n      await this.walletManagerQuerier.call<GetUserWalletStatusRpcReturnType>({\n        procedureName: \"getUserStatus\",\n        params: undefined,\n      });\n    if (userStatus.status === UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED) {\n      return {\n        status: UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,\n        user: { ...userStatus.user, wallet: this },\n      };\n    }\n    return userStatus;\n  }\n\n  /**\n   * @description\n   * Switches the chain that the user wallet is currently on.\n   * @example\n   * // user wallet will be set to Polygon\n   * const Paper = new PaperEmbeddedWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   * const user = await Paper.initializeUser();\n   * // Switch the user wallet to Mumbai\n   * await user.wallet.setChain({ chain: \"Mumbai\" });\n   * @param {Chain} params.chain The chain that we are changing the user wallet too\n   */\n  async setChain({ chain }: { chain: Chain }): Promise<void> {\n    this.chain = chain;\n    this.gasless = new GaslessTransactionMaker({\n      chain,\n      clientId: this.clientId,\n      querier: this.walletManagerQuerier,\n    });\n  }\n\n  /**\n   * Returns an Ethers.Js compatible signer that you can use in conjunction with the rest of dApp\n   * @example\n   * const Paper = new PaperEmbeddedWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   * const user = await Paper.getUser();\n   * if (user.status === UserStatus.LOGGED_IN_WALLET_INITIALIZED) {\n   *    // returns a signer on the Polygon mainnet\n   *    const signer = await user.getEthersJsSigner();\n   *    // returns a signer on the specified RPC endpoints\n   *    const signer = await user.getEthersJsSigner({rpcEndpoint: \"https://eth-rpc.gateway.pokt.network\"});\n   * }\n   * @param {Networkish} network.rpcEndpoint the rpc url where calls will be routed through\n   * @throws If attempting to call the function without the user wallet initialize on their current device. This should never happen if call {@link PaperEmbeddedWalletSdk.initializeUser} before accessing this function\n   * @returns A signer that is compatible with Ether.js. Defaults to the public rpc on the chain specified when initializing the {@link PaperEmbeddedWalletSdk} instance\n   */\n  async getEthersJsSigner(network?: {\n    rpcEndpoint: Networkish;\n  }): Promise<EthersSigner> {\n    const signer = new EthersSigner({\n      clientId: this.clientId,\n      provider: getDefaultProvider(\n        network?.rpcEndpoint ?? ChainToPublicRpc[this.chain],\n      ),\n      querier: this.walletManagerQuerier,\n    });\n    return signer;\n  }\n}\n", "import type { Chain } from \"@paperxyz/sdk-common-utilities\";\nimport type { ClientIdWithQuerierAndChainType } from \"../../interfaces/EmbeddedWallets/EmbeddedWallets\";\nimport type {\n  CallContractReturnType,\n  ContractCallInputType,\n} from \"../../interfaces/EmbeddedWallets/GaslessTransactionMaker\";\nimport type { EmbeddedWalletIframeCommunicator } from \"../../utils/iFrameCommunication/EmbeddedWalletIframeCommunicator\";\n\nexport type GaslessTransactionQuerierTypes = {\n  callContract: {\n    contractAddress: string;\n    method: {\n      stub: string;\n      args: Array<unknown>;\n    };\n    chain: Chain;\n  };\n};\n\n/**\n * @description GaslessTransactionMaker is used to execute gasless transactions from the embedded wallets\n */\nexport class GaslessTransactionMaker {\n  protected chain: Chain;\n  protected clientId: string;\n  protected gaslessTransactionQuerier: EmbeddedWalletIframeCommunicator<GaslessTransactionQuerierTypes>;\n  constructor({ chain, clientId, querier }: ClientIdWithQuerierAndChainType) {\n    this.chain = chain;\n    this.clientId = clientId;\n    this.gaslessTransactionQuerier = querier;\n  }\n  /**\n   * @description\n   * Use to call arbitrary contracts on the blockchain. Note that you have to enable {@link https://withpaper.com/dashboard/developers Sponsored Fees} in order for this to work.\n   *\n   * @param {string} params.contractAddress The address for which the contract call is directed too.\n   * @param {string} params.methodInterface the function stub on the contract. This looks something like `function myFunctionName(address user, uint256 tokenId) external payable`. Refer to this {@link https://blog.ricmoo.com/human-readable-contract-abis-in-ethers-js-141902f4d917 ethers.js article} for more.\n   * @param {Array} params.methodArgs The arguments that is to be passed to the contract in order that they are to be passed to the contract.\n   * @throws if there is an error calling the contract for whatever reason.\n   * @returns {{ transactionHash: string }} The transaction hash associated with the successful contract call.\n   */\n  async callContract({\n    contractAddress,\n    methodArgs,\n    methodInterface,\n  }: ContractCallInputType): Promise<CallContractReturnType> {\n    return await this.gaslessTransactionQuerier.call<CallContractReturnType>({\n      procedureName: \"callContract\",\n      params: {\n        chain: this.chain,\n        contractAddress,\n        method: {\n          args: methodArgs,\n          stub: methodInterface,\n        },\n      },\n    });\n  }\n}\n", "import type {\n  Provider,\n  TransactionRequest,\n} from \"@ethersproject/abstract-provider\";\nimport type {\n  TypedDataDomain,\n  TypedDataField,\n} from \"@ethersproject/abstract-signer\";\nimport { Signer } from \"@ethersproject/abstract-signer\";\nimport type { Bytes } from \"@ethersproject/bytes\";\nimport type { Deferrable } from \"@ethersproject/properties\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport type { ClientIdWithQuerierType } from \"../../interfaces/EmbeddedWallets/EmbeddedWallets\";\nimport type {\n  GetAddressReturnType,\n  SignedTypedDataReturnType,\n  SignMessageReturnType,\n  SignTransactionReturnType,\n} from \"../../interfaces/EmbeddedWallets/Signer\";\n\nimport type { EmbeddedWalletIframeCommunicator } from \"../../utils/iFrameCommunication/EmbeddedWalletIframeCommunicator\";\n\nexport type SignerProcedureTypes = {\n  getAddress: void;\n  signMessage: { message: string | Bytes; chainId: number | undefined };\n  signTransaction: {\n    transaction: Deferrable<TransactionRequest>;\n    chainId: number | undefined;\n  };\n  signTypedDataV4: {\n    domain: TypedDataDomain;\n    types: Record<string, Array<TypedDataField>>;\n    message: Record<string, unknown>;\n    chainId: number | undefined;\n  };\n  connect: { provider: Provider };\n};\n\nexport class EthersSigner extends Signer {\n  protected querier: EmbeddedWalletIframeCommunicator<SignerProcedureTypes>;\n  protected clientId: string;\n  private DEFAULT_ETHEREUM_CHAIN_ID = 1;\n  constructor({\n    provider,\n    clientId,\n    querier,\n  }: ClientIdWithQuerierType & {\n    provider: Provider;\n  }) {\n    super();\n    this.clientId = clientId;\n    this.querier = querier;\n    defineReadOnly(this, \"provider\", provider);\n  }\n\n  override async getAddress(): Promise<string> {\n    const { address } = await this.querier.call<GetAddressReturnType>({\n      procedureName: \"getAddress\",\n      params: undefined,\n    });\n    return address;\n  }\n\n  override async signMessage(message: string | Bytes): Promise<string> {\n    const { signedMessage } = await this.querier.call<SignMessageReturnType>({\n      procedureName: \"signMessage\",\n      params: {\n        message,\n        chainId:\n          (await this.provider?.getNetwork())?.chainId ??\n          this.DEFAULT_ETHEREUM_CHAIN_ID,\n      },\n    });\n    return signedMessage;\n  }\n\n  override async signTransaction(\n    transaction: TransactionRequest,\n  ): Promise<string> {\n    const { signedTransaction } =\n      await this.querier.call<SignTransactionReturnType>({\n        procedureName: \"signTransaction\",\n        params: {\n          transaction,\n          chainId:\n            (await this.provider?.getNetwork())?.chainId ??\n            this.DEFAULT_ETHEREUM_CHAIN_ID,\n        },\n      });\n    return signedTransaction;\n  }\n\n  async _signTypedData(\n    domain: SignerProcedureTypes[\"signTypedDataV4\"][\"domain\"],\n    types: SignerProcedureTypes[\"signTypedDataV4\"][\"types\"],\n    message: SignerProcedureTypes[\"signTypedDataV4\"][\"message\"],\n  ): Promise<string> {\n    const { signedTypedData } =\n      await this.querier.call<SignedTypedDataReturnType>({\n        procedureName: \"signTypedDataV4\",\n        params: {\n          domain,\n          types,\n          message,\n          chainId:\n            (await this.provider?.getNetwork())?.chainId ??\n            this.DEFAULT_ETHEREUM_CHAIN_ID,\n        },\n      });\n    return signedTypedData;\n  }\n\n  override connect(provider: Provider): EthersSigner {\n    return new EthersSigner({\n      clientId: this.clientId,\n      provider,\n      querier: this.querier,\n    });\n  }\n}\n", "import type {\n  GetUser,\n  PaperConstructorType,\n} from \"../interfaces/EmbeddedWallets/EmbeddedWallets\";\nimport {\n  UserStatus,\n  UserWalletStatus,\n} from \"../interfaces/EmbeddedWallets/EmbeddedWallets\";\nimport { EmbeddedWalletIframeCommunicator } from \"../utils/iFrameCommunication/EmbeddedWalletIframeCommunicator\";\nimport type { AuthQuerierTypes } from \"./Auth\";\nimport { Auth } from \"./Auth\";\nimport { EmbeddedWallet } from \"./EmbeddedWallets/EmbeddedWallet\";\n\nexport class PaperEmbeddedWalletSdk {\n  protected clientId: string;\n  protected querier: EmbeddedWalletIframeCommunicator<AuthQuerierTypes>;\n\n  private wallet: EmbeddedWallet;\n  /**\n   * Used to manage the Auth state of the user.\n   */\n  auth: Auth;\n\n  /**\n   * @example\n   * const Paper = new PaperEmbeddedWalletSdk({ clientId: \"\", chain: \"Goerli\" });\n   * @param {string} initParams.clientId the clientId found on the {@link https://withpaper.com/dashboard/developers developer's dashboard}\n   * @param {Chain} initParams.chain sets the default chain that the EmbeddedWallet will live on.\n   * @param {CustomizationOptionsType} initParams.styles sets the default style override for any modal that pops up asking for user's details when creating wallet or logging in.\n   */\n  constructor({ clientId, chain, styles }: PaperConstructorType) {\n    this.clientId = clientId;\n    this.querier = new EmbeddedWalletIframeCommunicator({\n      clientId,\n      customizationOptions: styles,\n    });\n    this.wallet = new EmbeddedWallet({\n      clientId,\n      chain,\n      querier: this.querier,\n    });\n\n    this.auth = new Auth({\n      clientId,\n      querier: this.querier,\n      onAuthSuccess: async (authResult) => {\n        await this.wallet.postWalletSetUp({\n          ...authResult.walletDetails,\n          walletUserId: authResult.storedToken.authDetails.userWalletId,\n        });\n        return {\n          user: {\n            status: UserStatus.LOGGED_IN_WALLET_INITIALIZED,\n            authDetails: authResult.storedToken.authDetails,\n            wallet: this.wallet,\n            walletAddress: authResult.walletDetails.walletAddress,\n          },\n        };\n      },\n    });\n  }\n\n  /**\n   * Gets the usr if they are logged in\n   * @example\n   *  const user = await Paper.getUser();\n   *  switch (user.status) {\n   *     case UserStatus.LOGGED_OUT: {\n   *       // User is logged out, call one of the auth methods on Paper.auth to authenticate the user\n   *       break;\n   *     }\n   *     case UserStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *       // user is logged in and wallet is all set up.\n   *       // You have access to:\n   *       user.status;\n   *       user.authDetails;\n   *       user.walletAddress;\n   *       user.wallet;\n   *       break;\n   *     }\n   *}\n   * @returns {GetUser} an object to containing various information on the user statuses\n   */\n  async getUser(): Promise<GetUser> {\n    const userStatus = await this.wallet.getUserWalletStatus();\n    switch (userStatus.status) {\n      // user gets {UserWalletStatus.LOGGED_IN_NEW_DEVICE} when they log in but never complete the recovery flow and exits (close modal, refresh etc)\n      case UserWalletStatus.LOGGED_IN_NEW_DEVICE:\n      // User gets {UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED} when they log in but manage to exit the client in the small window between auth completion and sending them their wallet recovery details\n      case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED:\n        // in both case, we simply log them out to reset their state\n        await this.auth.logout();\n        return this.getUser();\n      case UserWalletStatus.LOGGED_OUT:\n        return {\n          status: UserStatus.LOGGED_OUT,\n        };\n      case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED:\n        return {\n          status: UserStatus.LOGGED_IN_WALLET_INITIALIZED,\n          ...userStatus.user,\n        };\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["ChainToPublicRpc", "isDev", "isOldPaperDomain", "getPaperOriginUrl", "_a", "init_lib", "init_lib", "EMBEDDED_WALLET_PATH", "WALLET_USER_ID_LOCAL_STORAGE_NAME", "clientId", "AUTH_TOKEN_LOCAL_STORAGE_PREFIX", "AUTH_TOKEN_LOCAL_STORAGE_NAME", "DEVICE_SHARE_LOCAL_STORAGE_PREFIX", "DEVICE_SHARE_LOCAL_STORAGE_NAME", "userId", "DEVICE_SHARE_LOCAL_STORAGE_NAME_DEPRECATED", "AuthProvider", "UserStatus", "UserWalletStatus", "data", "LocalStorage", "key", "__async", "_a", "value", "item", "cookie", "share", "sleep", "seconds", "resolve", "iframeBaseStyle", "isIframeLoaded", "IframeCommunicator", "link", "iframeId", "container", "iframeStyles", "onIframeInitialize", "iframe", "hrefLink", "sdkVersion", "mergedIframeStyles", "__spreadValues", "prePostMessageSleepInSeconds", "res", "rej", "channel", "event", "INIT_IFRAME_EVENT", "getPaperOriginUrl", "_0", "procedureName", "params", "showIframe", "EmbeddedWalletIframeCommunicator", "customizationOptions", "EMBEDDED_WALLET_IFRAME_ID", "createEmbeddedWalletIframeLink", "localStorage", "path", "queryParams", "embeddedWalletUrl", "queryKey", "Auth", "querier", "onAuthSuccess", "storedToken", "walletDetails", "token", "authProvider", "recoveryCode", "result", "email", "isNewUser", "isNewDevice", "otp", "success", "isRemoveAuthCookie", "isRemoveUserId", "GaslessTransactionMaker", "chain", "contractAddress", "methodArgs", "methodInterface", "EthersSigner", "Signer", "provider", "defineReadOnly", "address", "message", "_b", "_c", "signedMessage", "transaction", "signedTransaction", "domain", "types", "signedTypedData", "EmbeddedWallet", "deviceShareStored", "walletAddress", "isIframeStorageEnabled", "walletUserId", "userStatus", "__spreadProps", "network", "getDefaultProvider", "ChainToPublicRpc", "PaperEmbeddedWalletSdk", "styles", "authResult"]
}
